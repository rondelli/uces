<!DOCTYPE html>
<html>
	<head>
		<title>Presentation</title>
		<link href="favicon.png" rel="icon" type="image/png"/>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
		<style type="text/css">
			@import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
			@import url(https://fonts.googleapis.com/css?family=Nunito:400,700,400italic);
			@import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

			body, p { font-family: 'Nunito'; font-size: 21px; }
			h1, h2, h3 {
				font-family: 'Yanone Kaffeesatz';
				font-weight: normal;
			}
			.remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; font-size: 21px; }
		</style>
	</head>
	<body>
		<textarea id="source">

class: center, middle
# Transacciones

## Bases de Datos II ‚Äï UCES

<br/>
<br/>

### Prof. Hern√°n Rondelli

### https://rondelli.github.io/uces/db2/trans.html

---

class: center, middle
# Transacciones ‚Äî Para qu√© sirven?

---

## Transacciones ‚Äî Para qu√© sirven?

- Acceso concurrente a los datos
- Resistencia a fallas

---

## Acceso concurrente 1‚Ä¶

### access ‚Üí read, modify, write

Supongamos dos modificaciones simult√°neas

**Acceso A**

```sql
update caja_de_ahorro set saldo = saldo + 1000 where n√∫mero_de_cuenta = 626;
```

**Acceso B**

```sql
update caja_de_ahorro set saldo = saldo + 2000 where n√∫mero_de_cuenta = 626;
```

<br/>

Si le cliente ten√≠a $10000 en su cuenta, cu√°nto dinero tiene ahora?

---

## ‚Ä¶Acceso concurrente 1

### access ‚Üí read, modify, write

<br/>

| Acceso A        | <span style=color:white>666</span> |  Acceso B |
|:---------------:|-|:---------------:|
| ‚Üì               | | ‚Üì               |
| `read(saldo)`   | |                 |
| `saldo += 1000` | |                 |
|                 | | `read(saldo)`   |
|                 | | `saldo += 2000` |
| `write(saldo)`  | |                 |
|                 | | `write(saldo)`  |

???

Esto se conoce como _lost update problem_.

---

## Acceso concurrente 2‚Ä¶

### access ‚Üí read, modify, write

Supongamos dos accesos simult√°neos

**Acceso A**

```sql
insert into alquiler select * from reserva where fecha = now()::date;
delete from reserva where fecha = now()::date;
```

**Acceso B**

```sql
select count(*) from reserva;
select count(*) from alquiler;
```

Observaci√≥n

```sql
now()::date == current_date
```

---

## ‚Ä¶Acceso concurrente 2

### access ‚Üí read, modify, write

| Acceso A                     | <span style=color:white>666</span> |  Acceso B  |
|------------------------------|------------------------------------|:----------:|
| .center[‚Üì]                   | |  ‚Üì |
| `insert into alquiler`       | |
| `select * from reserva`      | |
| `where fecha = now()::date;` | |
|                              | | .left[`select count(*) from reserva;`]
|                              | | .left[`select count(*) from alquiler;`]
| `delete from reserva`        | |
| `where fecha = now()::date;` | |

???

Esto se conoce como _incorrect summary problem_.

---

## Resistencia a fallas

Estamos procesando los alquileres y las reservas‚Ä¶

```sql
insert into alquiler select * from reserva where fecha = current_date;
delete from reserva where fecha = current_date;
```

pero Edenor nos corta la luz justo antes del `delete`!!! üòø

---

# Transacci√≥n

_Es una secuencia de operaciones SQL que se tratan como una unidad_

- Cada transacci√≥n se ejecuta aisladamente
- Todo √≥ nada: se ejecuta completamente, √≥ no se ejecuta nada

---

class: center, middle
# Propiedades ACID

---

## Propiedades ACID

- Atomicity
- Consistency
- Isolation
- Durability

---

## Atomicity

- **Todo √≥ nada:** se ejecuta completamente, √≥ no se ejecuta nada
- La transacci√≥n siempre termina en `commit` √≥ en `rollback`

|            |       |
|-----------:|:-----:|:---------------------------------------
| `commit`   | **‚Üí** | la transacci√≥n se complet√≥ exitosamente
| `rollback` | **‚Üí** | undo de una transacci√≥n parcial

---

## Consistency

Una transacci√≥n **nunca** deja a la base de datos en un estado **inconsistente**

- Cuando una transacci√≥n comienza, la base de datos est√° en un estado consistente
- Cuando una transacci√≥n termina, se garantiza que la base de datos est√° en un estado consistente

---

## Isolation

- Cada transacci√≥n **no** v√© lo que otra transacci√≥n est√° haciendo
- Las transacciones se procesan concurrentemente
- Los resultados de una transacci√≥n deben ser los mismos que la ejecuci√≥n secuencial de las operaciones

**Serializaci√≥n:** Las operaciones se pueden entrelazar pero la ejecuci√≥n debe ser equivalente a _alg√∫n_ orden secuencial de todas las transacciones

---

## Ejemplo de serializaci√≥n

**T1**

```sql
update caja_de_ahorro set saldo = saldo + 1000 where n√∫mero_de_cuenta = 626;
```

**T2**

```sql
update caja_de_ahorro set saldo = saldo + 2000 where n√∫mero_de_cuenta = 626;
```

<br/>

‚úÖ  T1, T2

‚úÖ  T2, T1

---

## Durability

Las operaciones sobre la base de datos **no deben** cambiar despu√©s de que se complet√≥ exitosamente la transacci√≥n

---

class: center, middle
# Isolation Levels

---

## Isolation

- Cada transacci√≥n **no** v√© lo que otra transacci√≥n est√° haciendo
- Las transacciones se procesan **concurrentemente**
- Los resultados de una transacci√≥n **deben ser los mismos** que la ejecuci√≥n secuencial de las operaciones

**Serializaci√≥n:** Las operaciones se pueden entrelazar pero la ejecuci√≥n debe ser equivalente a _alg√∫n_ orden secuencial de todas las transacciones

‚úÖ  T1, T2, T3, T7, T10, T8, T9, T6, T4, T5

**Observaci√≥n: es v√°lido s√≥lo para serializable**

---

## Isolation Levels (por transacci√≥n)

Weaker to Stronger:

| <span style=color:white>66666666666666666</span> | <span style=color:white>lucifer</span> |
|:----------------------|:-:|----------------------------------
| <span style=color:red>1. `read uncommitted`</span> |     | ‚Üì + Overhead
| <span style=color:orange>2. `read committed`</span>   |  | ‚Üì &#8722; Concurrency
| <span style=color:#F4BC1C>3. `repeatable read`</span>  | | ‚Üì + Consistencia


| <span style=color:white>66666666666666666</span> | <span style=color:white>lucifer</span> |
|:----------------------|-|----------------------------------
| <span style=color:green>4. `serializable`</span>     | | **> Overhead**
|                       | | **< Concurrency**
|                       | | <span style="background-color:green;color:white">100% Consistencia</span>

---

## Dirty Read

Cuando una transacci√≥n lee un valor escrito por una transacci√≥n `uncommitted`

**T1**

```sql
-- saldo ‚Üí 10000
begin;
update caja_de_ahorro set saldo = saldo + 5000 where n√∫mero_de_cuenta = 626;
*-- saldo ‚Üí 15000
-- ac√° podemos tener un rollback
commit;
```

**T2 (`read uncommitted`)**

```sql
begin;
‚Ä¶
*select saldo from caja_de_ahorro where n√∫mero_de_cuenta = 626;
commit;
```

---

## read uncommitted

La transacci√≥n puede tener valores **dirty reads**

```sql
begin;
set transaction isolation level read uncommitted;
/* operaciones */
commit;
```

---

## read committed

La transacci√≥n **no** puede tener valores dirty reads **(todav√≠a no garantiza serializaci√≥n)**

**T1**

```sql
begin;
update cambio set compra = 25.75 where moneda = 'Dolar';
commit;
```

**T2**

```sql
begin;
set transaction isolation level read committed;
select max(compra) from cambio where moneda = 'Dolar';
‚Ä¶
select max(compra) from cambio where moneda = 'Dolar';
commit;
```

---

## repeatable read

- La transacci√≥n **no** puede tener valores dirty reads
- Un valor le√≠do m√°s de una vez, no puede cambiar
- **(todav√≠a no garantiza serializaci√≥n)**

**T1**

```sql
begin;
update cambio set compra = 25.75 where moneda = 'Dolar';
update cambio set venta = 25.95 where moneda = 'Dolar';
commit;
```

**T2**

```sql
begin;
set transaction isolation level repeatable read;
select avg(compra) from cambio;
select avg(venta) from cambio;
commit;
```

---

## repeatable read ‚Üí phantom tuples

- La transacci√≥n **no** puede tener valores dirty reads
- Un valor le√≠do m√°s de una vez, no puede cambiar
- **(todav√≠a no garantiza serializaci√≥n)**

**T1**

```sql
begin;
insert into cambio ["compra y venta para varias monedas"];
commit;
```

**T2**

```sql
begin;
set transaction isolation level repeatable read;
select * from cambio;
select avg(compra) from cambio;
select max(compra) from cambio;
commit;
```
---

## serializable

- **Garantiza serializaci√≥n**

```sql
begin;
set transaction isolation level serializable;
/* operaciones */
commit;
```

---

## read only

```sql
begin;
set transaction read only;
select * from materia;
select avg(nota) from materia_aprobada where legajo = 626;
select nombre, apellido from alumno order by apellido;
commit;
```

---

## Bibliograf√≠a

Elmasri and Navathe, _Fundamentals of database systems_

  - Secciones 20.1, 20.3, y 20.6

---

class: center, middle

.center[<img src="img/questions.png" alt="image" width="400"/>]

		</textarea>
		<script src="../out/remark.js"></script>
		<!--
		<script src="../out/MathJax-2.4-latest/MathJax.js"></script>
		-->
		<script type="text/javascript">
			var slideshow = remark.create({
				ratio: '16:9',
				highlightLines:'true'
			});

			MathJax.Hub.Config({
				extensions: ["tex2jax.js"],
				jax: ["input/TeX","output/SVG"],
				tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
			});

			MathJax.Hub.Configured();
		</script>
	</body>
</html>
